#pragma config(Sensor, S1, US, sensorEV3_Ultrasonic)
#pragma config(Sensor, S4, CS, sensorEV3_Color)
#pragma config(Motor, motorA, leftWheel, tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor, motorB, armMotor, tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor, motorD, rightWheel, tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* Global Var */
// green light intensity
int greenMin = 12;
int greenMax = 15;

// blue light intensity
int blueMin = 6;
int blueMax = 11;

int bgColour = 35; // outside (line) colour range

int objectDistance = 10; // obstacle away from sensor

/* Function List */
void resetEncoders(); // set motor encoders in wheels to 0
void twoSecBeep();	  // 2 sec beep
void stopWheels();	  // set wheel speed to 0
void lineTracking();  // move while detecting line
void moveObstacle();  // moves obstacle in green line
void turnAround();	  // turns around 180 deg for obstacle in blue line

/* main func */
task main()
{
	while (true)
	{
		lineTracking(); // track line

		// obstacle scenario
		if (SensorValue[US] <= objectDistance)
		{
			stopWheels(); // bot stops
			twoSecBeep(); // beeps for 2 sec

			if ((SensorValue[CS] >= greenMin) && (SensorValue[CS] <= greenMax)) //green line
			{
				resetEncoders(); // motor encoders is reset
				
				while ((SensorValue[US] >= 0) && (nMotorEncoder(leftWheel) < 300))
				{ // move until near the obstacle 
					setMotorSpeed(leftWheel, 30);
					setMotorSpeed(rightWheel, 30);
				}

				resetEncoders(); // before moving to next process
				stopWheels();

				moveObstacle(); // move obstacle away from the track
			}

			else if ((SensorValue[CS] >= blueMin) &&(SensorValue[CS] <= blueMax)) //blue line 
			{
				turnAround(); // turn 180 deg
			}

			else if ((SensorValue[CS] > greenMax) && (SensorValue[CS] <= bgColour))
			{
				setMotorTarget(rightWheel, 37.8, 15); // bot turns left 10 deg (POV: from above)
				waitUntilMotorStop(rightWheel);
			}
		}
	}
}

/* Function Def. */
// move while detecting line
void lineTracking()
{
	// bot move right (within colour range)
	if ((SensorValue[CS] >= blueMin) && (SensorValue[CS] <= greenMax))
	{
		setMotorSpeed(leftWheel, 25);
		setMotorSpeed(rightWheel, 15);
	}
	// bot move left (outside of colour range)
	else if ((SensorValue[CS] >= greenMax) && (SensorValue[CS] < bgColour))
	{
		setMotorSpeed(leftWheel, 15);
		setMotorSpeed(rightWheel, 25);
	}
	// 90 deg right turn (if path exists to left)
	else if (SensorValue[CS] > bgColour)
	{
		bool isLeftExist = false;
		stopWheels(); // stop moving
		resetEncoders();

		while ((nMotorEncoder(rightWheel) < 180)) // 90 deg left (if path exists to right)
		{
			if (SensorValue[CS] <= greenMax)
			{
				isLeftExist = true; // found a line to the left
				break;
			}
			
			// search for the line in left
			setMotorSpeed(leftWheel, -5); 
			setMotorSpeed(rightWheel, 5);
		}

		stopWheels(); // stop moving
		resetEncoders();
		
		// if path exists to right
		while ((nMotorEncoder(leftWheel) < 360) && (isLeftExist == false)) // 180 deg clockwise
		{
			if (SensorValue[CS] <= greenMax) // detects line
			{
				stopWheels();
				resetEncoders();
				
				// bot turns right 45 deg (to re-adjust its position w/line)
				setMotorTarget(leftWheel, 170, 5); 
				waitUntilMotorStop(leftWheel);
				break;
			}
			// search for the line in right
			setMotorSpeed(leftWheel, 5);
			setMotorSpeed(rightWheel, -5);
		}
	}
}
// set motor encoders to 0
void resetEncoders()
{
	resetMotorEncoder(leftWheel);
	resetMotorEncoder(rightWheel);
}

// set wheel speed to 0
void stopWheels()
{
	setMotorSpeed(leftWheel, 0);
	setMotorSpeed(rightWheel, 0);
}

// 2 sec beep
void twoSecBeep()
{
	for (int i = 1; i < 3; i++)
	{
		playSoundFile("Error alarm");
		sleep(1000);
	}
}

// moves obstacle in green line
void moveObstacle()
{
	setMotorTarget(leftWheel, 113.3, 50); // bot turns right 30 deg
	waitUntilMotorStop(leftWheel);

	resetEncoders();

	while (nMotorEncoder[leftWheel] < 500)
	{
		setMotorSpeed(leftWheel, 30);
		setMotorSpeed(rightWheel, 30);
	}

	while (nMotorEncoder[leftWheel] > 0) // move back to original position
	{
		setMotorSpeed(leftWheel, -30);
		setMotorSpeed(rightWheel, -30);
	}

	stopWheels(); // stop moving

	setMotorTarget(leftWheel, -113.3, 50); // bot turns right 30 deg (back to line)
	waitUntilMotorStop(leftWheel);
}

// turns around 180 deg for obstacle in blue line
void turnAround()
{
	resetEncoders();

	while (nMotorEncoder[leftWheel] < 300)
	{
		setMotorSpeed(leftWheel, 30);
		setMotorSpeed(rightWheel, -30);
	}
	stopWheels();
}
