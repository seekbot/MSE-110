#pragma config(Sensor, S1, US, sensorEV3_Ultrasonic)
#pragma config(Sensor, S4, CS, sensorEV3_Color)
#pragma config(Motor, motorA, leftWheel, tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor, motorB, armMotor, tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor, motorD, rightWheel, tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*In Virtual Worlds,
left wheel - Port 'B'  and right wheel - Port 'C'.
Sonar sensor - Port '4' and Color Sensor - Port '3'.
Our bot:
left wheel - Port 'A' and right wheel  - Port 'D'.
Sonar sensor - Port '1' and Color Sensor - Port '4'*/

/* Global Var */
int greenMin = 12;
int greenMax = 15;

int blueMin = 6;
int blueMax = 11;

int bgColour = 35;

int objectDistance = 10;

/* Function List */
void resetEncoders(); // set motor encoders in wheels to 0
void twoSecBeep();	  // 2 sec beep
void stopWheels();	  // set wheel speed to 0
void lineTracking();  // move while detecting line
void moveObstacle();  // moves obstacle in green line
void turnAround();	  // turns around 180 deg for obstacle in blue line

/* main func */
task main()
{
	while (true)
	{
		lineTracking(); // detect line

		// obstacle scenario
		if (SensorValue[US] <= objectDistance)
		{
			stopWheels(); // bot stops
			twoSecBeep(); // beeps for 2 sec

			if ((SensorValue[CS] >= greenMin) && (SensorValue[CS] <= greenMax)) //green line - subject to change light intensity range
			{
				resetEncoders();
				while ((SensorValue[US] >= 0) && (nMotorEncoder(leftWheel) < 300))
				{
					setMotorSpeed(leftWheel, 30);
					setMotorSpeed(rightWheel, 30);
				}

				resetEncoders();
				stopWheels();

				moveObstacle(); // move obstacle
			}

			else if ((SensorValue[CS] >= blueMin) &&(SensorValue[CS] <= blueMax)) //blue line - subject to change light intensity range
			{
				turnAround(); // turn 180 deg
			}

			else if ((SensorValue[CS] > greenMax) && (SensorValue[CS] <= bgColour))
			{
				setMotorTarget(rightWheel, 37.8, 15); // bot turns left 10 deg
				waitUntilMotorStop(rightWheel);
			}
		}
	}
}

/* Function Def. */
// move while detecting line
void lineTracking()
{
	// bot move right (within colour range)
	if ((SensorValue[CS] >= blueMin) && (SensorValue[CS] <= greenMax))
	{
		setMotorSpeed(leftWheel, 25);
		setMotorSpeed(rightWheel, 15);
	}
	// bot move left (outside of colour range)
	else if ((SensorValue[CS] >= greenMax) && (SensorValue[CS] < bgColour))
	{
		setMotorSpeed(leftWheel, 15);
		setMotorSpeed(rightWheel, 25);
	}
	// 90 deg right turn (if path exists to left)
	else if (SensorValue[CS] > bgColour)
	{
		bool isLeftExist = false;
		stopWheels();
		resetEncoders();

		while ((nMotorEncoder(rightWheel) < 180)) // 90 deg left (if path exists to right)
		{
			if (SensorValue[CS] <= greenMax)
			{
				isLeftExist = true;
				break;
			}

			setMotorSpeed(leftWheel, -5);
			setMotorSpeed(rightWheel, 5);
		}

		stopWheels();
		resetEncoders();

		while ((nMotorEncoder(leftWheel) < 360) && (isLeftExist == false)) // 180 deg clockwise
		{
			if (SensorValue[CS] <= greenMax) // detects line
			{
				stopWheels();
				resetEncoders();
				setMotorTarget(leftWheel, 170, 5); // bot turns right 45 deg
				waitUntilMotorStop(leftWheel);
				break;
			}
			setMotorSpeed(leftWheel, 5);
			setMotorSpeed(rightWheel, -5);
		}
	}
}
// set motor encoders to 0
void resetEncoders()
{
	resetMotorEncoder(leftWheel);
	resetMotorEncoder(rightWheel);
}

// set wheel speed to 0
void stopWheels()
{
	setMotorSpeed(leftWheel, 0);
	setMotorSpeed(rightWheel, 0);
}

// 2 sec beep
void twoSecBeep()
{
	for (int i = 1; i < 3; i++)
	{
		playSoundFile("Error alarm");
		sleep(1000);
	}
}

// moves obstacle in green line
void moveObstacle()
{
	setMotorTarget(leftWheel, 113.3, 50); // bot turns right 30 deg
	waitUntilMotorStop(leftWheel);

	resetEncoders();

	while (nMotorEncoder[leftWheel] < 500)
	{
		setMotorSpeed(leftWheel, 30);
		setMotorSpeed(rightWheel, 30);
	}

	while (nMotorEncoder[leftWheel] > 0) // move back to original position
	{
		setMotorSpeed(leftWheel, -30);
		setMotorSpeed(rightWheel, -30);
	}

	stopWheels(); // stop moving

	setMotorTarget(leftWheel, -113.3, 50); // bot turns right 30 deg (back to line)
	waitUntilMotorStop(leftWheel);
}

// turns around 180 deg for obstacle in blue line
void turnAround()
{
	resetEncoders();

	while (nMotorEncoder[leftWheel] < 300)
	{
		setMotorSpeed(leftWheel, 30);
		setMotorSpeed(rightWheel, -30);
	}
	stopWheels();
}
